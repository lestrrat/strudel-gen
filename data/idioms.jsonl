{"name":"acidenv","cat":"effects","desc":"Slider-controlled acid filter envelope via register()","notes":"Credit: Switch Angel. Registers \"acidenv\" as a reusable method. The first argument (x) is typically driven by slider(1) (range 0-1). At x=0, the filter stays closed at 100 Hz (dark/muffled). At x=0.5, a moderate filter sweep gives a plucky wah-like character. At x=1, a full sweep produces bright aggressive transients. Useful for live performance builds, tension control (low for verses, high for drops), and expressive filter knob-style playing.","code":"register('acidenv', (x, pat) =>\n  pat\n    .lpf(100)          // low-pass filter cutoff at 100 Hz\n    .lpenv(x * 9)      // LP envelope mod depth (scaled by x)\n    .lps(0.1)          // LP envelope sustain amplitude (0.1)\n    .lpd(.1)           // LP envelope decay time (0.1s)\n    .lpq(2)            // LP resonance factor (2)\n)"}
{"name":"active-inactive","cat":"live-performance","desc":"Toggle patterns on/off with underscore prefix on reactive statements","notes":"Prefix a reactive statement with _ to mute it. Easier than commenting out lines during live performance.","code":"// In strudel, you can automatically include patterns in the\n// currently playing pattern by using the `$:` reactive statement.\n$: s(\"bd sd\").fast(2)\n\n// You can make a named reactive statement as well.\nGROOVE: s(\"bd sd\").fast(2)\n\n// You can also disable these reactive statements by adding a leading underscore.\n_$: s(\"hh!8\").gain(0.5)\n_HH: s(\"hh!8\").gain(0.5)\n\n// These patterns are sometimes more favorable for live-coding, because\n// they are easier to enable/disable on the fly without having to\n// comment/uncomment lines, or change variable values."}
{"name":"add-semitones-vs-scale-degrees","cat":"melody","desc":"n().scale() uses scale degree indices while note() uses semitones (half steps)","notes":"With n().scale(), numbers are positions in the scale (0=root, 1=second, 2=third...). With note(), numbers are MIDI semitones. Adding works in those respective units.","code":"// KEY DISTINCTION:\n// n().scale() — numbers are SCALE DEGREE INDICES (0, 1, 2... = root, 2nd, 3rd...)\n// note()     — numbers are SEMITONES / half steps (MIDI note numbers)\n\n// These two produce the same note (D):\nconst x1 = n(\"0!8\".add(\"<1>\")).scale(\"C:major\").s(\"piano\")\n// Scale degree 0 = C, add 1 scale degree = scale degree 1 = D\n\nconst x2 = note(\"c3!8\".add(\"<2>\")).s(\"piano\")\n// C3 = MIDI 48, add 2 semitones = MIDI 50 = D3\n\n// WHY THE DIFFERENCE?\n// In C major, C to D is one scale degree but TWO semitones (whole step).\n// So +1 scale degree ≠ +1 semitone.\n\n// PRACTICAL IMPLICATIONS:\n// Use n().scale() when you want to stay diatonic (in key)\n// Use note() when you want chromatic control (exact intervals)\n\nstack(x1, x2)"}
{"name":"arrangement-mask","cat":"arrangement","desc":"Multi-bar build-up using mask() for section control","notes":"Binary patterns with slow() create arrangement timelines. 0=silent, 1=playing. Loops automatically.","code":"// 16-bar structure: intro (1-4), build (5-8), drop (9-16)\nconst enterBuild = \"0!4 1!12\".slow(16)\nconst enterDrop = \"0!8 1!8\".slow(16)\n\nconst kick = s(\"bd!4\").gain(0.9)\nconst bass = n(\"<0 0 3 5>\").scale(\"C2:minor\").s(\"sawtooth\").mask(enterBuild)\nconst arp = n(\"0 2 4 7\".fast(4)).scale(\"C4:minor\").s(\"supersaw\").mask(enterDrop)\n\nstack(kick, bass, arp)"}
{"name":"beat-switcher","cat":"live-performance","desc":"Array of beat variations with index selector for live switching","notes":"Change `beat` index live to switch patterns. Use struct() with t/~ for readable rhythms.","code":"const beat = 0\nconst beats = [\n  stack(\n    s(\"bd\").struct(\"t ~ t ~\"),\n    s(\"sd\").struct(\"~ t ~ t\"),\n  ),\n  stack(\n    s(\"bd\").struct(\"t ~ [t t] ~\"),\n    s(\"sd\").struct(\"~ t ~ t\"),\n  ),\n  stack(\n    s(\"bd\").struct(\"t [~ t] [~ t] ~\"),\n    s(\"sd\").struct(\"~ t ~ t\"),\n  ),\n]\n\nbeats[beat]"}
{"name":"blues-walking-bass-alternation","cat":"rhythm","desc":"Adding randomness to blues walking bass — alternation must preserve voice leading and blues harmony","notes":"In blues, walking bass has strict voice-leading rules. When using <> alternation for variation: (1) BOTH alternatives must walk stepwise to the following note; (2) B natural should ONLY appear as chromatic passing tone (Bb->B->C), never after a leap — it's not a chord tone in blues; (3) Each bar must clearly outline the chord (root beat 1, 3rd typically beat 2); (4) \"Random walking bass\" via irand() is not walking bass — walking requires deliberate voice leading, not random scale degrees.","code":"// WRONG: Alternation where one option creates a leap to B natural\n// If Strudel picks G2, we get G2->B2 (major 3rd leap)\n// B natural after a leap sounds wrong — in blues it's only a passing tone\nconst badAlternation = note(\"[C2 E2 <G2 Bb2> B2]\")\n  .s(\"gm_acoustic_bass\")\n// G2 -> B2 is a leap AND B isn't approached chromatically\n\n// WRONG: Random scale degrees is NOT walking bass\nconst notWalking = n(irand(6))\n  .struct(\"x*4\")\n  .scale(\"C2:blues\")\n  .s(\"gm_acoustic_bass\")\n// This is chaos — no voice leading, no chord outline, not blues\n\n// WRONG: Alternation that uses a note outside the chord\nconst noThird = note(\"[F2 <A2 Ab2> C3 B2]\")\n  .s(\"gm_acoustic_bass\")\n// F7 has A natural (major 3rd), not Ab — bar loses its blues identity\n\n// CORRECT: Both alternatives walk stepwise to the next note\n// G2->Bb2 is minor 3rd (acceptable in blues), A2->Bb2 is half step\nconst goodAlternation = note(\"[C2 E2 <G2 A2> Bb2]\")\n  .s(\"gm_acoustic_bass\")\n\n// CORRECT: B natural only after Bb (chromatic approach to C)\nconst correctBNatural = note(\"[F2 A2 Bb2 B2]\")\n  .s(\"gm_acoustic_bass\")\n// Bb->B->C is the classic blues chromatic walk to the root\n\n// CORRECT: 12-bar blues with safe alternation points\n// I(4) - IV(2) - I(2) - V - IV - I - V turnaround\nconst bassLine = note(`<\n  [C2 E2 G2 A2]\n  [C2 E2 <G2 A2> Bb2]\n  [C2 E2 G2 A2]\n  [C2 E2 A2 E2]\n  [F2 A2 C3 <D3 Eb3>]\n  [F2 A2 Bb2 B2]\n  [C2 E2 G2 A2]\n  [C2 E2 A2 F#2]\n  [G2 B2 A2 G2]\n  [F2 A2 Bb2 B2]\n  [C2 E2 <G2 A2> F#2]\n  [G2 B2 D3 B2]\n>`)\n  .s(\"gm_acoustic_bass\")\n  .gain(\"0.85 0.7 0.75 0.7\")\n  .lpf(900)\n// Safe alternation points for blues:\n// - Bar 2 beat 3: G2 or A2, both step to Bb2\n// - Bar 5 beat 4: D3 or Eb3, both valid dominant 7th extensions\n// - Bar 11 beat 3: G2 or A2, both step down to F#2\n\nbassLine"}
{"name":"chromatic-approaches","cat":"melody","desc":"Walking bass must approach target notes by step — use chromatic passing tones to avoid jumps","notes":"Walking bass lines move stepwise. When you need to connect two notes more than a whole step apart, fill in chromatic passing tones. The approach note (last note before the target) should be a half step away. For blues, use the flat 7 (e.g., Bb when approaching C) rather than the natural 7 for authentic sound.","code":"// WRONG: Jump from D to F (minor 3rd gap)\n// Bar 4 ends on D, bar 5 starts on F — no passing tone\nconst badBar4 = \"c3 e3 eb3 d3\"\nconst bar5 = \"f2 a2 c3 eb3\"\n// Listener expects stepwise motion but hears a skip\n\n// CORRECT: End bar 4 on E (half step below F)\nconst goodBar4 = \"c3 bb2 ab2 e2\"  // chromatic descent landing on approach note\n// E -> F is a half step — smooth voice leading\n\n// BLUES CHROMATIC APPROACHES:\n// Approaching C from below: a -> bb -> b -> c (use flat 7, not natural 7)\n// Approaching F from below: d -> eb -> e -> f\n// Approaching G from below: e -> f -> gb -> g (or f#)\n\n// WRONG: Using natural 7 approach (sounds too \"clean\", not bluesy)\nconst cleanApproach = \"g2 a2 b2 c3\"  // works but lacks blues character\n\n// CORRECT: Flat 7 approach for blues feel\nconst bluesApproach = \"g2 a2 bb2 b2\"  // bb is the blue note, b is the leading tone\n// The bb -> b -> c motion is characteristic of blues bass\n\nnote(cat(goodBar4, bar5)).s(\"sawtooth\").lpf(400)"}
{"name":"edm-foghorn","cat":"effects","desc":"Classic EDM foghorn sound using supersaw with long release","notes":"The long rel(5) creates the signature foghorn tail. beat(2, 32) with slow(2) spaces out the hits. Slightly detuned fmh(2.04) adds richness.","code":"const foghorn = s(\"supersaw\")\n  .detune(1)\n  .rel(5)\n  .beat(2, 32)\n  .slow(2)\n  .fm(2)\n  .fmh(2.04)\n\nfoghorn"}
{"name":"edm-noise-texture","cat":"effects","desc":"Evolving white noise texture with rhythmic variation","notes":"Sine-modulated decay creates movement. sometimesBy(0.1, ...) adds occasional rhythmic glitches via ply.","code":"const noise = s(\"white!16\")\n  .decay(sine.fast(4).range(0.05, .14))\n  .gain(0.6)\n  .sometimesBy(0.1, x => x.ply(\"2|4\"))\n\nnoise"}
{"name":"edm-pulse-buildup","cat":"effects","desc":"Pulse sound that builds intensity over time using FM modulation","notes":"fm(time) and fmh(time) increase modulation depth and harmonicity as time progresses, creating an evolving buildup effect.","code":"const pulse = s(\"pulse\")\n  .seg(16)\n  .dec(0.1)\n  .fm(time)\n  .fmh(time)\n  .gain(0.5)\n\npulse"}
{"name":"grooves-amen-break","cat":"rhythm","desc":"Classic amen break with humanized hi-hats and arranged kick/snare variations","notes":"Three beat variations arranged over 4 cycles. Hi-hats use rand for humanized timing and velocity.","code":"setcpm(130/4) // Set tempo: 130 BPM in 4/4 (cpm = BPM/4)\n\n// Beat 1 — primary kick/snare pattern (plays for 2 of 4 cycles)\nconst beat1 = s(\n  \"[[bd!2] [sd@3 sd@1] [~ sd bd!2] [sd@3 sd@1]]\"\n  //  2 kicks  dotted sd     rest→sd→2 kicks  dotted sd\n  //           + ghost sd    (syncopation)     + ghost sd\n)\n  ._pianoroll() // Inline pianoroll visualization\n\n// Beat 2 — variation: last beat is rest + ghost snare pickup\nconst beat2 = s(\n  \"[[bd!2] [sd@3 sd@1] [~ sd bd@2] [~@3 sd@1]]\"\n  //                     rest→sd→    3/4 rest\n  //                     held kick   + ghost sd\n)\n  ._pianoroll() // Inline pianoroll visualization\n\n// Beat 3 — variation: opens with rest→snare instead of kicks\nconst beat3 = s(\n  \"[[~ sd bd!] [sd@3 sd@1] [~ sd bd@2] [~@3 sd@1]]\"\n  //  rest→sd→2 kicks (pickup into dotted snare)\n)\n  ._pianoroll() // Inline pianoroll visualization\n\n// Hi-hats — 8th notes with humanized timing and velocity\nconst hh = s(\"hh!8\")                // 8 hi-hats per cycle (8th notes)\n  .nudge(rand.range(0, 0.015))      // Random timing shift 0–15ms (humanize)\n  .gain(rand.range(0.7, 1))         // Random gain 0.7–1.0 (humanize)\n  ._pianoroll()                      // Inline pianoroll visualization\n\n\n// Full amen break — hats layered with arranged kick/snare\nconst amen = stack(                  // Play patterns simultaneously\n  hh,                                // Continuous hi-hats\n  arrange(                           // Sequence patterns over cycles\n    [2, beat1],                      // beat1 for 2 cycles\n    [1, beat2],                      // beat2 for 1 cycle\n    [1, beat3],                      // beat3 for 1 cycle\n  )._pianoroll()                     // Inline pianoroll for arrangement\n)\n\n$: amen                              // Play the full amen break"}
{"name":"grooves-four-on-the-floor","cat":"rhythm","desc":"Four-on-the-floor kick pattern with live-coding toggle trick","notes":"Use commented-out .rib(0, 1/4) to quickly switch between two-step and four-on-the-floor during a live set.","code":"// simple method\ns(\"bd!4\")\n\n// for live-coding where you might alternate between four on the floor and\n// two step, you might do this (including the comments after)\n\ns(\"[bd sd]!2\") // basic two step\n//    .rib(0, 1/4) // uncomment to get four on the floor on the fly"}
{"name":"grooves-metronome","cat":"rhythm","desc":"4/4 metronome click track with accented downbeat","notes":"Uses sawtooth for a sharp click. First beat is pitched up and louder. Adjust gain to taste for your setup.","code":"// 4/4 metronome / click track\n// struct/add/gain should be tuned according to the setup\n\nconst click = s(\"sawtooth\").struct(\"t!4\")\n  .note(\"c5\".add(\"3 0 0 0\"))\n  .clip(0.25)\n  .gain(\"1 0.25!3\")"}
{"name":"multi-bar-form","cat":"rhythm","desc":"Use alternation <> for multi-bar chord progressions — don't add .slow()","notes":"Each element in <> already plays for one cycle (bar). Adding .slow(N) multiplies the duration, not divides it. For a 12-bar blues, use 12 elements in <>, not <4 elements>.slow(12).","code":"// WRONG: .slow(12) makes each of the 12 elements last 12 cycles = 144 cycles total\n// const badRoots = \"<0!4 3!2 0!2 4 3 0 4>\"\n// n(badRoots).slow(12)  // 144 cycles, not 12!\n\n// CORRECT: <> alternation already gives one element per cycle\n// 12 elements = 12 bars, no .slow() needed\n\n// 12-bar blues in C: I(4) IV(2) I(2) V IV I V\n// Using chord() for pad voicings — parallel motion is fine here\nconst progression = chord(\"<C!4 F!2 C!2 G F C G>\")\n  .voicing()\n  .s(\"supersaw\")\n  .room(0.3)\n\nprogression"}
{"name":"random-freeze","cat":"live-performance","desc":"Generate random pattern, then freeze a repeatable slice with ribbon()","notes":"Tweak the first ribbon() param (offset) to scrub through random space and find a pattern you like. The second param controls loop length in cycles.","code":"// Random clap pattern frozen at offset 19, looping 2 cycles\nconst cp = s(\"cp!16?\").degradeBy(0.6).ribbon(19, 2)\n\n// The technique works with any randomized pattern:\n// - Change offset (19) to explore different random configurations\n// - Change cycles (2) to control loop length\n// - Works with irand, rand, ?, degradeBy, etc.\n\n// Example with melodic randomness:\n// n(irand(8).segment(4)).scale(\"C:minor\").ribbon(42, 4)"}
{"name":"string-concatenation","cat":"syntax","desc":"Use single quotes for string concatenation — double quotes and backticks are transpiled as mini-notation","notes":"Only single-quoted strings behave as plain JS strings. Double quotes and backticks trigger mini-notation parsing, breaking concatenation.","code":"// CORRECT: single quotes only\n'c4' + ':major'  // → \"c4:major\"\n\n// WRONG: double quotes are mini-notation\n// \"c4\" + ':major'   // fails — \"c4\" is transpiled\n// 'c4' + \":major\"   // fails — \":major\" is transpiled\n// \"c4\" + \":major\"   // fails — both are transpiled"}
{"name":"walking-bass","cat":"rhythm","desc":"A walking bass moves stepwise — transposing a pattern with .add() doesn't create true walking motion","notes":"Walking bass lines move by steps with chromatic passing tones, not by preserving an interval pattern. Using .add() to transpose a fixed pattern creates parallel motion (arpeggiation), not walking. For authentic walking bass, write out lines per chord using note() with actual note names, and use cat() to sequence them. For blues feel: include the flat 7 (dominant 7) in chromatic approaches — e.g., approaching C use \"a bb b\" not \"ab a b\". The flat 7 is the characteristic blues note; omitting it sounds cleaner but loses the bluesy quality.","code":"// WRONG: Using .add() to transpose a pattern\n// This preserves intervallic contour — it's arpeggiation, not walking\nconst chordRoots = \"<0!4 3!2 0!2 4 3 0 4>\"\nconst arpeggioPattern = \"0 2 4 5\"\nconst notWalking = n(arpeggioPattern)\n  .add(n(chordRoots))\n  .scale(\"E2:blues\")\n  .s(\"sawtooth\")\n// Over I chord: E A B D (jumping by 3rds)\n// Over IV chord: A D E G (still jumping — not stepwise!)\n\n// CORRECT: Write actual walking lines with chromatic passing tones\n// Use note() with explicit note names for chromatic control\n// Use cat() to sequence bars\n\n// 12-bar blues in C: C/F/C/C/F/F/C/C/G/F/C/G\nconst walkingBassBars = [\n  \"c3 bb2 a2 g2\",\n  \"f2 a2 a#2 b2\",\n  \"c3 e3 g3 bb3\",\n  \"c4 bb3 a3 g3\",\n  \"f3 eb3 c3 a2\",\n  \"f2 a2 bb2 b2\",\n  \"c3 e3 f3 gb3\",\n  \"g3 a3 bb3 c4\",\n  \"g3 f3 e3 g3\",\n  \"f3 eb3 d3 db3\",\n  \"c3 bb2 a2 ab2\",\n  \"g2 a2 bb2 b2\",\n]\n\nconst walkingBass = note(cat(...walkingBassBars))\n  .s(\"sawtooth\")\n\nwalkingBass"}
